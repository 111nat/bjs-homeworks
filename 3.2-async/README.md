# Домашнее задание к лекции 3.2 «Асинхронность» 

## Задача №1. Будильник-колыбельная

Помогите старому знакомому Васе (он уже студент 1 курса, кстати) перестать просыпать на пары. 
Для этого нужно написать Программу-будильник-колыбельную с возможностью добавления, удаления, запусков и остановки будильника.

## Процесс реализации

1. Необходимо написать класс *AlarmClock* со следующими методами:

* `constructor` - выделяет память для объекта. 
	* Создайте свойство для хранения коллекции звонков с начальным значением пустого массива. 
	* Создайте свойство для хранения `id` таймера без начального значения.

* `addClock` - добавляет новый звонок в коллекцию существующих. 
	* Принимает параметр времени в формате `HH:MM` - время, когда должно запустится действие.
	* Принимает параметр функции-колбека - действие, которое должно запустится.
	* Принимает параметр идентификатора создаваемого звонка - необязательный числовой параметр.
	* Проверьте, если есть какой-нибудь звонок с уже существующим `id`, то завершите выполнение метода.
	* Если параметр `id` не передан, то нужно его сгенерировать **случайным целым числом** от 0 до 100. Повторяйте это действие пока коллекция звонков не пустая **И** для у каждого звонка `id` отличается от сгенерированного.
	* Добавьте в массив звонков объект со свойствами `id`, `time`, `callback`.

* `removeClock` - удаляет определённый звонок.
	* Принимает `id` звонка, который следует удалить.
	* Удалите из массива звонков тот, у которого `id` совпадает с текущим. (например можно использовать метод `filter`).
	* Верните логическое значение об успешности/провале удаления объекта звонка из общего массива.

* `getCurrentFormattedTime` - возвращает текущее время в строковом формате `HH:MM`.

* `start` - запускает все звонки
	* Создайте функцию, которая принимает будильник и проверяет: если текущее время совпадает со временем звонка, то вызывайте колбек.
	* Если значение текущего таймера отсутствует, то создайте интервал, в котором вызывайте функцию, в которой для каждого звонка вызывайте функцию описанную на предыдущем пункте. Интервал обхода всех звонков с проверкой каждого сделайте одну секунду.
	* Результат функции `setInterval` сохраните в свойстве идентификатора текущего таймера.

* `stop` - останавливает все выполнение звонков
	* Сделайте проверку существования идентификатора текущего таймера.
	* Если у идентификатора текущего таймера есть значение, то вызовите функцию `clearInterval` для удаления интервала, а так же удалите значение из свойства идентификатора текущего таймера.

* `printAlarms` - печатает все звонки
	* С помощью метода `forEach` выведите информацию о каждом будильнике (`id` и `time`)

* `clearAlarms` - удаляет все звонки

2. Напишите пример использования класса *AlarmClock* (Реализуйте и запустите функцию `testCase`): 

* Создайте объект класса `AlarmClock`.
* Добавьте в созданный объект новый будильник с текущим временем и колбеком вывода текста на консоль. Так, что бы после запуска, функция вывода *выполнилась несколько раз*.
* Добавьте ещё один будильник со временем +1 минуты от текущего времени и колбеком: вывода текста на консоль, а так же удалением этого звонка. Так, что бы после запуска, функция вывода *выполнилась один раз, а потом удалилась*.
* Добавьте ещё один будильник со временем +2 минут от текущего времени и колбеком (создайте этот будильник **без id**): вывода текста на консоль, а так же остановки всех звонков, очистки всех звонков и выводом всех звонков. Так, что бы после запуска, функция вывода *выполнилась один раз, потом остановился интервал, все будильники очистились, и ничего не вывелось*.
* Напечатайте все будильники (должно вывестись 3 звонка).
* Запустите выполнение ваших звонков.

Результат работы должен быть примерно таким:

![](https://sun9-27.userapi.com/c857728/v857728864/107812/phEoelosztU.jpg)
* Первый будильник был выведен 35 раз, так как запустился посередине минуты срабатывания и не работал всю минуту.
* После последнего звонка была выполнена печать звонков после удаления: их осталось 0.

### Критерии выполнения

1. Использовать цикл можно **только один раз** в случае генерации `id` звонка, так как неизвестно сколько раз нужно генерировать `id`.
2. Используйте *функции высшего порядка*, такие как `some`, `every`, `forEach`, `filter` для перебора коллекции звонков
3. Функция `testCase` может отличаться от описания в задании. Главное показать:
	* Создание объекта будильника.
	* Добавление нескольких звонков, с генерацией и без генерации `id`
	* Удаление звонков в зависимости от условия
	* Печать звонков перед удалением и после (для доказательства того, что звонки действительно добавляются и удаляются)
	* Запуск звонков и **срабатывание в нужное время**
	* Остановка звонков

## Требования для выполнения домашней работы

* браузер;
* редактор кода, например [Sublime][1] или [Visual Studio Code][2];
* аккаунт на [GitHub][0] ([инструкция по регистрации на GitHub][3]);
* система контроля версий [Git][4], установленная локально ([инструкция по установке Git][5]);

## Начало работ

1. Создать репозиторий на [GitHub][0]. Параметры создаваемого репозитория:
* Repository name: `bjs-homeworks`;
* Access level: Public;
* Initialize this repository with a README: No;
* Add .gitignore: None;
* Add a license: None;
После нажатия на кнопку `Create repository`, вы будете переведены на страницу вновь созданного репозитория.
URL адрес текущей страницы будет являться URL адресом вашего репозитория.
Пример URL адреса репозитория: `https://github.com/username/bjs-homeworks`, где `username` - имя вашего профиля GitHub, `bjs-homeworks` - название репозитория. Далее по тексту адрес вашего репозитория будет иметь обозначение: `%repo-url%`.
2. Создать директорию на вашем компьютере, в которой вы планируете выполнять домашние задания.
3. Открыть созданную директорию с помощью терминала или командной строки вашей операционной системы.
4. Клонировать репозиторий с домашними заданиями с помощью команды `git clone https://github.com/netology-code/bjs-homeworks` в открывшемся терминале или командной строке.
5. Перейти в директория склонированного репозитория `cd ./bjs-homeworks`.
6. Добавить репозиторий в проект `git remote add homeworks %repo-url%`, где `%repo-url%` — адрес созданного репозитория.

## Решение задач
1. Перейти в папку задания, например, для первого задания `cd ./async`.
2. Открыть файл `main.js` в вашем редакторе кода и выполнить задание.
3. Открыть файл `index.html` в вашем браузере и с помощью консоли DevTools убедиться в правильности выводимых результатов.
4. Добавить файл `main.js` в индекс git с помощью команды `git add %file-path%`, где %file-path% - путь до целевого файла, например, для первого задания `git add async/main.js`.
5. Сделать коммит используя команду `git commit -m '%comment%'`, где %comment% - это произвольный комментарий к вашему коммиту, например, для первого задания 'first commit async'.
6. Опубликовать код в репозиторий homeworks с помощью команды `git push -u homeworks master`.
7. Прислать ссылку на репозиторий через личный кабинет на сайте [Нетологии][6].

[0]: https://github.com/
[1]: https://www.sublimetext.com/
[2]: https://code.visualstudio.com/
[3]: https://github.com/netology-code/guides/blob/master/git/github.md
[4]: https://git-scm.com/
[5]: https://github.com/netology-code/guides/blob/master/git/REAMDE.md
[6]: https://netology.ru/

*Никаких файлов прикреплять не нужно.*

Все задачи обязательны к выполнению для получения зачета. Присылать на проверку можно каждую задачу по отдельности или все задачи вместе. Во время проверки по частям ваша домашняя работа будет со статусом "На доработке".

Любые вопросы по решению задач задавайте в Slack-канале.
